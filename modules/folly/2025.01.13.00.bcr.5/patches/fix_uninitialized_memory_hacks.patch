diff --git a/folly/memory/UninitializedMemoryHacks.h b/folly/memory/UninitializedMemoryHacks.h
index daf5eb735..22e0014b4 100644
--- a/folly/memory/UninitializedMemoryHacks.h
+++ b/folly/memory/UninitializedMemoryHacks.h
@@ -309,7 +309,11 @@ struct std_vector_layout {
 
   pointer __begin_;
   pointer __end_;
-  std::__compressed_pair<pointer, allocator_type> __end_cap_;
+#ifdef _LIBCPP_COMPRESSED_PAIR
+  _LIBCPP_COMPRESSED_PAIR(pointer, __cap_ = nullptr, allocator_type, __alloc_);
+#else
+   std::__compressed_pair<pointer, allocator_type> __end_cap_;
+#endif
 };
 
 template <typename T>
@@ -332,10 +336,19 @@ void unsafeVectorSetLargerSize(std::vector<T>& v, std::size_t n) {
   // enabled we need to call the appropriate annotation functions in order to
   // stop ASAN from reporting false positives. When ASAN is disabled, the
   // annotation function is a no-op.
-#ifndef _LIBCPP_HAS_NO_ASAN
+#if defined(_LIBCPP_HAS_ASAN)
+#define FOLLY_ASAN_ANNOTATE_CONTIGUOUS_CONTAINER _LIBCPP_HAS_ASAN
+#elif defined(_LIBCPP_HAS_NO_ASAN)
+#define FOLLY_ASAN_ANNOTATE_CONTIGUOUS_CONTAINER 0
+#else
+#define FOLLY_ASAN_ANNOTATE_CONTIGUOUS_CONTAINER 1
+#endif
+
+#if FOLLY_ASAN_ANNOTATE_CONTIGUOUS_CONTAINER
   __sanitizer_annotate_contiguous_container(
       v.data(), v.data() + v.capacity(), v.data() + s, v.data() + n);
 #endif
+
 }
 
 #define FOLLY_DECLARE_VECTOR_RESIZE_WITHOUT_INIT(TYPE)
