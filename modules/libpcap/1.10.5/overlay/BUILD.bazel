load("@rules_cc//cc:cc_library.bzl", "cc_library")
load("@rules_cc//cc:cc_test.bzl", "cc_test")
load("@rules_cc_autoconf//autoconf:autoconf.bzl", "autoconf")
load("@rules_cc_autoconf//autoconf:autoconf_hdr.bzl", "autoconf_hdr")
load("@rules_cc_autoconf//autoconf:checks.bzl", "checks")
load("@rules_cc_autoconf//autoconf:package_info.bzl", "package_info")
load(":libpcap_utils.bzl", "libpcap_bison", "libpcap_flex")

licenses(["notice"])

exports_files(["LICENSE"])

package_info(
    name = "package",
    package_name = "pcap",
    package_version = "1.10.5",
)

# All autoconf checks ported directly from configure.ac.
# Libpcap does not use gnulib; every check lives here.
autoconf(
    name = "autoconf",
    checks = [
        # ── AC_PROG_CC_C99 (line 109) ──
        checks.AC_PROG_CC(),

        # ── AC_CHECK_SIZEOF (lines 118, 124) ──
        checks.AC_CHECK_SIZEOF(
            "void *",
            define = "SIZEOF_VOID_P",
        ),
        checks.AC_CHECK_SIZEOF(
            "time_t",
            define = "SIZEOF_TIME_T",
            includes = ["#include <time.h>"],
        ),

        # ── Standard headers (AC_CHECK_HEADERS_DEFAULT / AC_HEADER_STDC) ──
        checks.AC_CHECK_HEADER(
            "inttypes.h",
            define = "HAVE_INTTYPES_H",
        ),
        checks.AC_CHECK_HEADER(
            "stdint.h",
            define = "HAVE_STDINT_H",
        ),
        checks.AC_CHECK_HEADER(
            "stdio.h",
            define = "HAVE_STDIO_H",
        ),
        checks.AC_CHECK_HEADER(
            "stdlib.h",
            define = "HAVE_STDLIB_H",
        ),
        checks.AC_CHECK_HEADER(
            "string.h",
            define = "HAVE_STRING_H",
        ),
        checks.AC_CHECK_HEADER(
            "strings.h",
            define = "HAVE_STRINGS_H",
        ),
        checks.AC_CHECK_HEADER(
            "sys/stat.h",
            define = "HAVE_SYS_STAT_H",
        ),
        checks.AC_CHECK_HEADER(
            "sys/types.h",
            define = "HAVE_SYS_TYPES_H",
        ),
        checks.AC_CHECK_HEADER(
            "unistd.h",
            define = "HAVE_UNISTD_H",
        ),

        # ── AC_CHECK_HEADERS (lines 146-147, 695, 750, 1009, 1110, 1289) ──
        checks.AC_CHECK_HEADER(
            "sys/ioccom.h",
            define = "HAVE_SYS_IOCCOM_H",
        ),
        checks.AC_CHECK_HEADER(
            "sys/sockio.h",
            define = "HAVE_SYS_SOCKIO_H",
        ),
        checks.AC_CHECK_HEADER(
            "netpacket/packet.h",
            define = "HAVE_NETPACKET_PACKET_H",
        ),
        checks.AC_CHECK_HEADER(
            "ifaddrs.h",
            define = "HAVE_IFADDRS_H",
        ),
        checks.AC_CHECK_HEADER(
            "pthread.h",
            define = "HAVE_PTHREAD_H",
        ),
        checks.AC_CHECK_HEADER(
            "net/bpf.h",
            define = "HAVE_NET_BPF_H",
        ),
        checks.AC_CHECK_HEADER(
            "net/if_media.h",
            define = "HAVE_NET_IF_MEDIA_H",
        ),
        checks.AC_CHECK_HEADER(
            "linux/socket.h",
            define = "HAVE_LINUX_SOCKET_H",
        ),
        checks.AC_CHECK_HEADER(
            "linux/wireless.h",
            define = "HAVE_LINUX_WIRELESS_H",
        ),
        checks.AC_CHECK_HEADER(
            "linux/net_tstamp.h",
            define = "HAVE_LINUX_NET_TSTAMP_H",
        ),
        checks.AC_CHECK_HEADER(
            "bluetooth/bluetooth.h",
            define = "HAVE_BLUETOOTH_BLUETOOTH_H",
        ),
        checks.AC_CHECK_HEADER(
            "linux/compiler.h",
            define = "HAVE_LINUX_COMPILER_H",
        ),
        checks.AC_CHECK_HEADER(
            "linux/usbdevice_fs.h",
            define = "HAVE_LINUX_USBDEVICE_FS_H",
        ),

        # ── AC_CHECK_FUNCS — required (lines 222-225) ──
        checks.AC_CHECK_FUNC(
            "vsnprintf",
            define = "HAVE_VSNPRINTF",
        ),
        checks.AC_CHECK_FUNC(
            "snprintf",
            define = "HAVE_SNPRINTF",
        ),

        # ── AC_CHECK_FUNCS — optional with missing/ fallbacks (lines 228-258) ──
        checks.AC_CHECK_FUNC(
            "vasprintf",
            define = "HAVE_VASPRINTF",
        ),
        checks.AC_CHECK_FUNC(
            "asprintf",
            define = "HAVE_ASPRINTF",
        ),
        checks.AC_CHECK_FUNC(
            "strlcat",
            define = "HAVE_STRLCAT",
        ),
        checks.AC_CHECK_FUNC(
            "strlcpy",
            define = "HAVE_STRLCPY",
        ),
        checks.AC_CHECK_FUNC(
            "strtok_r",
            define = "HAVE_STRTOK_R",
        ),
        checks.AC_CHECK_FUNC(
            "ffs",
            name = "ac_cv_func_ffs",
            define = "HAVE_FFS",
        ),

        # ── AC_CHECK_FUNCS — other (lines 135, 217, 437, 596, 1755, 1775) ──
        checks.AC_CHECK_FUNC(
            "fseeko",
            define = "HAVE_FSEEKO",
        ),
        checks.AC_CHECK_FUNC(
            "vsyslog",
            define = "HAVE_VSYSLOG",
        ),
        checks.AC_CHECK_FUNC(
            "ether_hostton",
            define = "HAVE_ETHER_HOSTTON",
        ),
        checks.AC_CHECK_FUNC(
            "pthread_create",
            define = "HAVE_PTHREAD_CREATE",
        ),
        checks.AC_CHECK_FUNC(
            "getifaddrs",
            define = "HAVE_GETIFADDRS",
        ),
        checks.AC_CHECK_FUNC(
            "crypt",
            define = "HAVE_CRYPT",
        ),
        checks.AC_CHECK_FUNC(
            "getspnam",
            define = "HAVE_GETSPNAM",
        ),

        # ── AC_CHECK_LIB (lines 164, 607, 619, 1760) ──
        checks.AC_CHECK_LIB(
            "bsd",
            "getpass",
            define = "HAVE_LIBBSD",
        ),
        checks.AC_CHECK_LIB(
            "pthreads",
            "pthread_create",
            define = "HAVE_LIBPTHREADS",
        ),
        checks.AC_CHECK_LIB(
            "pthread",
            "pthread_create",
            define = "HAVE_LIBPTHREAD",
        ),
        checks.AC_CHECK_LIB(
            "crypt",
            "crypt",
            define = "HAVE_LIBCRYPT",
        ),

        # ── AC_CHECK_TYPES (lines 974, 1115, 1299, 2528, 2783) ──
        checks.AC_CHECK_TYPE(
            "socklen_t",
            define = "HAVE_SOCKLEN_T",
            includes = [
                "#include <sys/socket.h>",
                "#include <sys/types.h>",
            ],
        ),
        checks.AC_CHECK_TYPE(
            "struct sockaddr_storage",
            define = "HAVE_STRUCT_SOCKADDR_STORAGE",
            includes = [
                "#include <sys/socket.h>",
                "#include <sys/types.h>",
            ],
        ),
        checks.AC_CHECK_TYPE(
            "struct ether_addr",
            define = "HAVE_STRUCT_ETHER_ADDR",
            includes = [
                "#include <net/if.h>",
                "#include <netinet/if_ether.h>",
                "#include <netinet/in.h>",
                "#include <sys/socket.h>",
                "#include <sys/types.h>",
            ],
        ),
        checks.AC_CHECK_TYPE(
            "dl_passive_req_t",
            define = "HAVE_DL_PASSIVE_REQ_T",
            includes = [
                "#include <sys/dlpi.h>",
                "#include <sys/types.h>",
            ],
        ),
        checks.AC_CHECK_TYPE(
            "struct BPF_TIMEVAL",
            define = "HAVE_STRUCT_BPF_TIMEVAL",
            includes = [
                "#include <net/bpf.h>",
                "#include <sys/ioctl.h>",
                "#include <sys/types.h>",
            ],
        ),
        checks.AC_CHECK_TYPE(
            "struct rte_ether_addr",
            define = "HAVE_STRUCT_RTE_ETHER_ADDR",
            includes = ["#include <rte_ether.h>"],
        ),

        # ── AC_CHECK_MEMBERS (lines 1094, 1780, 1785, 2519, 2545, 2604, 2918) ──
        checks.AC_CHECK_MEMBER(
            "struct sockaddr.sa_len",
            define = "HAVE_STRUCT_SOCKADDR_SA_LEN",
            includes = [
                "#include <sys/socket.h>",
                "#include <sys/types.h>",
            ],
        ),
        checks.AC_CHECK_MEMBER(
            "struct tpacket_auxdata.tp_vlan_tci",
            define = "HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI",
            includes = [
                "#include <linux/if_packet.h>",
                "#include <sys/types.h>",
            ],
        ),
        checks.AC_CHECK_MEMBER(
            "struct msghdr.msg_control",
            define = "HAVE_STRUCT_MSGHDR_MSG_CONTROL",
            includes = ["#include <sys/socket.h>"],
        ),
        checks.AC_CHECK_MEMBER(
            "struct msghdr.msg_flags",
            define = "HAVE_STRUCT_MSGHDR_MSG_FLAGS",
            includes = ["#include <sys/socket.h>"],
        ),
        checks.AC_CHECK_MEMBER(
            "struct sockaddr_hci.hci_channel",
            define = "HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL",
            includes = [
                "#include <bluetooth/bluetooth.h>",
                "#include <bluetooth/hci.h>",
            ],
        ),
        checks.AC_CHECK_MEMBER(
            "struct usbdevfs_ctrltransfer.bRequestType",
            define = "HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE",
            includes = ["#include <linux/usbdevice_fs.h>"],
        ),
        checks.AC_CHECK_MEMBER(
            "dl_hp_ppa_info_t.dl_module_id_1",
            define = "HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1",
            includes = [
                "#include <sys/dlpi.h>",
                "#include <sys/dlpi_ext.h>",
                "#include <sys/types.h>",
            ],
        ),

        # ── strerror_r style detection (lines 172-212) ──
        # First check whether strerror_r exists, then determine GNU vs POSIX.
        # The define "HAVE_STRERROR_R" isn't in config.h.in but is used to
        # gate the subsequent GNU/POSIX checks via requires.
        checks.AC_CHECK_FUNC(
            "strerror_r",
            define = "HAVE_STRERROR_R",
        ),
        checks.AC_TRY_COMPILE(
            code = """\
#define _GNU_SOURCE
#include <string.h>

/* Define it GNU-style; that will cause an error if it's not GNU-style */
extern char *strerror_r(int, char *, size_t);

int main(void) { return 0; }
""",
            define = "HAVE_GNU_STRERROR_R",
            requires = ["HAVE_STRERROR_R=1"],
        ),
        checks.AC_DEFINE(
            "HAVE_POSIX_STRERROR_R",
            "",
            requires = [
                "HAVE_STRERROR_R=1",
                "!HAVE_GNU_STRERROR_R",
            ],
        ),

        # ── ffs declaration in strings.h (lines 258-273) ──
        # Only check if ffs() itself exists.
        checks.AC_CHECK_DECL(
            "ffs",
            define = "STRINGS_H_DECLARES_FFS_TEST",
            includes = ["#include <strings.h>"],
            requires = ["ac_cv_func_ffs=1"],
        ),
        checks.AC_DEFINE(
            "STRINGS_H_DECLARES_FFS",
            "/**/",
            requires = ["STRINGS_H_DECLARES_FFS_TEST=1"],
        ),

        # ── ether_hostton declaration — sequential fallback (lines 438-585) ──
        # Each check needs a unique name since they all test the same symbol.
        checks.AC_CHECK_DECL(
            "ether_hostton",
            name = "ac_cv_have_decl_ether_hostton_net_ethernet_h",
            define = "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST",
            includes = ["#include <net/ethernet.h>"],
            requires = ["HAVE_ETHER_HOSTTON=1"],
        ),
        checks.AC_DEFINE(
            "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON",
            "",
            requires = ["NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=1"],
        ),
        checks.AC_CHECK_DECL(
            "ether_hostton",
            name = "ac_cv_have_decl_ether_hostton_netinet_ether_h",
            define = "NETINET_ETHER_H_DECLARES_ETHER_HOSTTON_TEST",
            includes = ["#include <netinet/ether.h>"],
            requires = [
                "HAVE_ETHER_HOSTTON=1",
                "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=0",
            ],
        ),
        checks.AC_DEFINE(
            "NETINET_ETHER_H_DECLARES_ETHER_HOSTTON",
            "",
            requires = ["NETINET_ETHER_H_DECLARES_ETHER_HOSTTON_TEST=1"],
        ),
        checks.AC_CHECK_DECL(
            "ether_hostton",
            name = "ac_cv_have_decl_ether_hostton_sys_ethernet_h",
            define = "SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST",
            includes = ["#include <sys/ethernet.h>"],
            requires = [
                "HAVE_ETHER_HOSTTON=1",
                "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=0",
                "NETINET_ETHER_H_DECLARES_ETHER_HOSTTON_TEST=0",
            ],
        ),
        checks.AC_DEFINE(
            "SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON",
            "",
            requires = ["SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=1"],
        ),
        checks.AC_CHECK_DECL(
            "ether_hostton",
            name = "ac_cv_have_decl_ether_hostton_arpa_inet_h",
            define = "ARPA_INET_H_DECLARES_ETHER_HOSTTON_TEST",
            includes = ["#include <arpa/inet.h>"],
            requires = [
                "HAVE_ETHER_HOSTTON=1",
                "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=0",
                "NETINET_ETHER_H_DECLARES_ETHER_HOSTTON_TEST=0",
                "SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=0",
            ],
        ),
        checks.AC_DEFINE(
            "ARPA_INET_H_DECLARES_ETHER_HOSTTON",
            "",
            requires = ["ARPA_INET_H_DECLARES_ETHER_HOSTTON_TEST=1"],
        ),
        checks.AC_CHECK_DECL(
            "ether_hostton",
            name = "ac_cv_have_decl_ether_hostton_netinet_if_ether_h",
            define = "NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON_TEST",
            includes = [
                "#include <net/if.h>",
                "#include <netinet/if_ether.h>",
                "#include <netinet/in.h>",
                "#include <sys/socket.h>",
                "#include <sys/types.h>",
            ],
            requires = [
                "HAVE_ETHER_HOSTTON=1",
                "NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=0",
                "NETINET_ETHER_H_DECLARES_ETHER_HOSTTON_TEST=0",
                "SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=0",
                "ARPA_INET_H_DECLARES_ETHER_HOSTTON_TEST=0",
            ],
        ),
        checks.AC_DEFINE(
            "NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON",
            "",
            requires = ["NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON_TEST=1"],
        ),
        checks.AC_DEFINE(
            "HAVE_DECL_ETHER_HOSTTON",
            "1",
            requires = ["NET_ETHERNET_H_DECLARES_ETHER_HOSTTON_TEST=1"],
        ),

        # ── getnetbyname_r / getprotobyname_r declarations (lines 295, 367) ──
        checks.AC_CHECK_DECL(
            "getnetbyname_r",
            define = "HAVE_DECL_GETNETBYNAME_R",
            includes = ["#include <netdb.h>"],
        ),
        checks.AC_CHECK_DECL(
            "getprotobyname_r",
            define = "HAVE_DECL_GETPROTOBYNAME_R",
            includes = ["#include <netdb.h>"],
        ),

        # ── getnetbyname_r API variants (lines 296-351) ──
        checks.AC_TRY_COMPILE(
            code = """\
#include <netdb.h>
int main(void) {
    struct netent netent_buf;
    char buf[1024];
    struct netent *resultp;
    int h_errnoval;
    return getnetbyname_r((const char *)0, &netent_buf, buf, sizeof buf, &resultp, &h_errnoval);
}
""",
            define = "HAVE_LINUX_GETNETBYNAME_R",
            requires = ["HAVE_DECL_GETNETBYNAME_R=1"],
        ),
        checks.AC_TRY_COMPILE(
            code = """\
#include <netdb.h>
int main(void) {
    struct netent netent_buf;
    char buf[1024];
    return getnetbyname_r((const char *)0, &netent_buf, buf, (int)sizeof buf) != NULL;
}
""",
            define = "HAVE_SOLARIS_IRIX_GETNETBYNAME_R",
            requires = [
                "HAVE_DECL_GETNETBYNAME_R=1",
                "HAVE_LINUX_GETNETBYNAME_R=0",
            ],
        ),
        checks.AC_TRY_COMPILE(
            code = """\
#include <netdb.h>
int main(void) {
    struct netent netent_buf;
    struct netent_data net_data;
    return getnetbyname_r((const char *)0, &netent_buf, &net_data);
}
""",
            define = "HAVE_AIX_GETNETBYNAME_R",
            requires = [
                "HAVE_DECL_GETNETBYNAME_R=1",
                "HAVE_LINUX_GETNETBYNAME_R=0",
                "HAVE_SOLARIS_IRIX_GETNETBYNAME_R=0",
            ],
        ),

        # ── getprotobyname_r API variants (lines 367-422) ──
        checks.AC_TRY_COMPILE(
            code = """\
#include <netdb.h>
int main(void) {
    struct protoent protoent_buf;
    char buf[1024];
    struct protoent *resultp;
    return getprotobyname_r((const char *)0, &protoent_buf, buf, sizeof buf, &resultp);
}
""",
            define = "HAVE_LINUX_GETPROTOBYNAME_R",
            requires = ["HAVE_DECL_GETPROTOBYNAME_R=1"],
        ),
        checks.AC_TRY_COMPILE(
            code = """\
#include <netdb.h>
int main(void) {
    struct protoent protoent_buf;
    char buf[1024];
    return getprotobyname_r((const char *)0, &protoent_buf, buf, (int)sizeof buf) != NULL;
}
""",
            define = "HAVE_SOLARIS_IRIX_GETPROTOBYNAME_R",
            requires = [
                "HAVE_DECL_GETPROTOBYNAME_R=1",
                "HAVE_LINUX_GETPROTOBYNAME_R=0",
            ],
        ),
        checks.AC_TRY_COMPILE(
            code = """\
#include <netdb.h>
int main(void) {
    struct protoent protoent_buf;
    struct protoent_data proto_data;
    return getprotobyname_r((const char *)0, &protoent_buf, &proto_data);
}
""",
            define = "HAVE_AIX_GETPROTOBYNAME_R",
            requires = [
                "HAVE_DECL_GETPROTOBYNAME_R=1",
                "HAVE_LINUX_GETPROTOBYNAME_R=0",
                "HAVE_SOLARIS_IRIX_GETPROTOBYNAME_R=0",
            ],
        ),

        # ── AC_PCAP_C___ATOMICS (aclocal.m4 line 688) ──
        checks.AC_TRY_COMPILE(
            code = """\
int main(void) {
    int x = 0;
    __atomic_load_n(&x, __ATOMIC_RELAXED);
    __atomic_store_n(&x, 1, __ATOMIC_RELAXED);
    return 0;
}
""",
            define = "HAVE___ATOMIC_LOAD_N",
        ),
        checks.AC_TRY_COMPILE(
            code = """\
int main(void) {
    int x = 0;
    __atomic_store_n(&x, 1, __ATOMIC_RELAXED);
    return 0;
}
""",
            define = "HAVE___ATOMIC_STORE_N",
        ),

        # ── Unconditional defines ──
        checks.AC_DEFINE("INET6", "1"),
        checks.AC_DEFINE("BUILDING_PCAP", "1"),

        # ── AC_SYS_LARGEFILE (line 134) ──
    ] + select({
        "@platforms//os:macos": [],
        "//conditions:default": [
            checks.AC_DEFINE("_FILE_OFFSET_BITS", "64"),
        ],
    }) + [
        # ── AC_HEADER_STDC ──
        checks.AC_DEFINE("STDC_HEADERS", "1"),

        # ── AC_PROG_LEX (line 1977) ──
        checks.AC_DEFINE("YYTEXT_POINTER", "1"),

        # ── AC_LBL_C_INLINE (aclocal.m4 line 642) ──
        checks.AC_DEFINE("inline", "inline"),

        # REENTRANT_PARSER is AC_SUBST (not AC_DEFINE); handled via
        # substitutions on the grammar_y autoconf_hdr target below.

        # ── Platform-specific defines ──
    ] + select({
        "@platforms//os:haiku": [
            checks.AC_DEFINE("_BSD_SOURCE", "1"),
        ],
        "@platforms//os:linux": [
            checks.AC_DEFINE("LINUX_USB_MON_DEV", '"/dev/usbmon"'),
            checks.AC_DEFINE("PCAP_SUPPORT_LINUX_USBMON", "1"),
            checks.AC_DEFINE("PCAP_SUPPORT_NETFILTER", "1"),
        ],
        "@platforms//os:macos": [
            checks.AC_DEFINE("_DARWIN_USE_64_BIT_INODE", "1"),
        ],
        "//conditions:default": [],
    }),
    visibility = ["//visibility:public"],
    deps = [":package"],
)

autoconf_hdr(
    name = "config",
    out = "config.h",
    template = "config.h.in",
    deps = [":autoconf"],
)

autoconf_hdr(
    name = "grammar_y",
    out = "grammar.y",
    substitutions = {"@REENTRANT_PARSER@": "%define api.pure"},
    template = "grammar.y.in",
    deps = [":autoconf"],
)

libpcap_bison(
    name = "grammar",
    srcs = [":grammar_y"],
    outs = [
        "grammar.c",
        "grammar.h",
    ],
    args = [
        "-p",
        "pcap_",
        "-o",
        "$(execpath grammar.c)",
        "-d",
        "$(execpath :grammar_y)",
    ],
    bison = "@bison",
)

libpcap_flex(
    name = "scanner",
    srcs = ["scanner.l"],
    outs = [
        "scanner.c",
        "scanner.h",
    ],
    args = [
        "-P",
        "pcap_",
        "--header-file=$(execpath scanner.h)",
        "--nounput",
        "-o",
        "$(execpath scanner.c)",
        "$(execpath scanner.l)",
    ],
    flex = "@flex",
)

LIBPCAP_COMMON_SRCS = [
    "bpf_dump.c",
    "bpf_filter.c",
    "bpf_image.c",
    "etherent.c",
    "fmtutils.c",
    "gencode.c",
    "nametoaddr.c",
    "optimize.c",
    "pcap-common.c",
    "pcap-util.c",
    "pcap.c",
    "savefile.c",
    "sf-pcapng.c",
    "sf-pcap.c",
    "missing/asprintf.c",
]

LIBPCAP_MISSING_SRCS = select({
    "@platforms//os:linux": ["missing/strlcpy.c"],
    "//conditions:default": [],
})

LIBPCAP_PLATFORM_SRCS = select({
    "@platforms//os:freebsd": ["pcap-bpf.c"],
    "@platforms//os:linux": [
        "pcap-linux.c",
        "pcap-usb-linux.c",
        "pcap-netfilter-linux.c",
    ],
    "@platforms//os:macos": ["pcap-bpf.c"],
    "@platforms//os:openbsd": ["pcap-bpf.c"],
    "@platforms//os:windows": ["pcap-win32.c"],
    "//conditions:default": ["pcap-null.c"],
})

LIBPCAP_FAD_SRCS = select({
    "@platforms//os:freebsd": ["fad-getad.c"],
    "@platforms//os:linux": ["fad-getad.c"],
    "@platforms//os:macos": ["fad-getad.c"],
    "@platforms//os:openbsd": ["fad-getad.c"],
    "//conditions:default": ["fad-getad.c"],
})

LIBPCAP_REMOTE_SRCS = []

LIBPCAP_PUBLIC_HDRS = [
    "pcap.h",
    "pcap-bpf.h",
    "pcap-namedb.h",
] + glob(["pcap/*.h"])

LIBPCAP_PRIVATE_HDRS = glob(
    ["*.h"],
    exclude = [
        "pcap.h",
        "pcap-bpf.h",
        "pcap-namedb.h",
    ],
)

[
    cc_library(
        name = name,
        srcs = LIBPCAP_COMMON_SRCS +
               LIBPCAP_PLATFORM_SRCS +
               LIBPCAP_FAD_SRCS +
               LIBPCAP_REMOTE_SRCS +
               LIBPCAP_MISSING_SRCS +
               LIBPCAP_PRIVATE_HDRS + [
            ":grammar",
            ":scanner",
        ],
        hdrs = LIBPCAP_PUBLIC_HDRS,
        includes = ["."],
        linkstatic = linkstatic,
        local_defines = [
            "HAVE_CONFIG_H",
        ],
        textual_hdrs = [":config"],
        visibility = ["//visibility:public"],
    )
    for name, linkstatic in {
        "pcap": False,
        "pcap_static": True,
    }.items()
]

alias(
    name = "libpcap",
    actual = ":pcap",
    visibility = ["//visibility:public"],
)

alias(
    name = "libpcap_static",
    actual = ":pcap_static",
    visibility = ["//visibility:public"],
)

##############################################################################
## Tests
##############################################################################

# can_set_rfmon_test requires a device name as argument
# Usage: can_set_rfmon_test <device>
cc_test(
    name = "can_set_rfmon_test",
    srcs = ["testprogs/can_set_rfmon_test.c"],
    # Mark as manual since it requires a network device argument
    tags = ["manual"],
    deps = [":libpcap"],
)

# capturetest requires device name and other options
# Usage: capturetest [options] [filter expression]
cc_test(
    name = "capturetest",
    srcs = ["testprogs/capturetest.c"],
    # Mark as manual since it requires a network device
    tags = ["manual"],
    deps = [":libpcap"],
)

# filtertest requires datalink type and filter expression
# Usage: filtertest [options] <datalink type> <filter expression>
# Can test with pcap_open_dead() which doesn't require a real device
cc_test(
    name = "filtertest",
    srcs = ["testprogs/filtertest.c"],
    # Test with a simple filter expression using EN10MB datalink type
    args = [
        "EN10MB",
        "host",
        "192.168.1.1",
    ],
    deps = [":libpcap"],
)

# findalldevstest can run without arguments (just lists devices)
cc_test(
    name = "findalldevstest",
    srcs = ["testprogs/findalldevstest.c"],
    # Can run without arguments, but may fail if no devices available
    tags = ["manual"],
    deps = [":libpcap"],
)

# findalldevstest-perf performance test
cc_test(
    name = "findalldevstest-perf",
    srcs = ["testprogs/findalldevstest-perf.c"],
    tags = ["manual"],
    deps = [":libpcap"],
)

# opentest requires device name and options
# Usage: opentest [options] <device>
cc_test(
    name = "opentest",
    srcs = ["testprogs/opentest.c"],
    tags = ["manual"],
    deps = [":libpcap"],
)

# reactivatetest doesn't require arguments (hardcoded to use "lo0" or "lo")
# It tests that pcap_activate() fails on an already-activated pcap_t
cc_test(
    name = "reactivatetest",
    srcs = ["testprogs/reactivatetest.c"],
    # May fail if loopback interface is not available
    tags = ["manual"],
    deps = [":libpcap"],
)

# writecaptest requires device name, savefile, and other options
# Usage: writecaptest [options] -w <savefile> [filter expression]
cc_test(
    name = "writecaptest",
    srcs = ["testprogs/writecaptest.c"],
    tags = ["manual"],
    deps = [":libpcap"],
)
