# Copyright 2026 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

load("@rules_rust//rust:defs.bzl", "rust_common")

def _record_rust_impl(ctx):
    rust_tc = ctx.toolchains["@rules_rust//rust:toolchain_type"]
    rustc_exec = rust_tc.rustc

    sh_tc = ctx.toolchains["@bazel_tools//tools/sh:toolchain_type"]  # provides sh_tc.path

    output_log = ctx.actions.declare_file(ctx.attr.outfile)

    direct_dep_crates = {}
    transitive_outputs = []
    search_paths = {}

    for dep in ctx.attr.deps:
        if rust_common.crate_info in dep:
            crate_info = dep[rust_common.crate_info]
            if crate_info.output:
                name = crate_info.name.replace("-", "_")
                direct_dep_crates[name] = crate_info.output

        if rust_common.dep_info in dep:
            dep_info = dep[rust_common.dep_info]
            for crate_info in dep_info.transitive_crates.to_list():
                if crate_info.output:
                    transitive_outputs.append(crate_info.output)
                    search_paths[crate_info.output.dirname] = True

    srcs = ctx.files.srcs

    # Build rustc args safely (avoid manual quoting)
    args = ctx.actions.args()
    args.add(srcs[0].path)
    args.add_all(["--crate-type", "rlib"])
    args.add_all(["--crate-name", ctx.label.name.replace("-", "_")])
    args.add_all(["-o", "lib{}.rlib".format(ctx.label.name.replace("-", "_"))])
    args.add_all(["--edition", str(ctx.attr.edition)])

    for feat in ctx.attr.crate_features:
        args.add_all(["--cfg", 'feature="{}"'.format(feat)])

    for name, out in direct_dep_crates.items():
        args.add("--extern")
        args.add("{}={}".format(name, out.path))

    for path in sorted(search_paths.keys()):
        args.add("-Ldependency={}".format(path))

    # Wrapper script that captures output to output_log and never fails the action
    wrapper = ctx.actions.declare_file(ctx.label.name + "_rustc_with_log.sh")
    ctx.actions.write(
        output = wrapper,
        is_executable = True,
        content = """#!{sh}
# Generated by {label}
# Run rustc and capture stdout/stderr to the log, never fail the action.
"{rustc}" "$@" > "{log}" 2>&1 || true
""".format(
            sh = sh_tc.path,
            label = ctx.label,
            rustc = rustc_exec.path,
            log = output_log.path,
        ),
    )

    ctx.actions.run(
        executable = wrapper,
        inputs = depset(
            srcs + transitive_outputs + list(direct_dep_crates.values()),
            transitive = [rust_tc.all_files],
        ),
        tools = [rustc_exec],
        outputs = [output_log],
        arguments = [args],
        env = rust_tc.env,
        mnemonic = "RustCompileWithLog",
    )

    return [DefaultInfo(files = depset([output_log]))]

rust_library_with_log = rule(
    implementation = _record_rust_impl,
    attrs = {
        "srcs": attr.label_list(allow_files = True, mandatory = True),
        "deps": attr.label_list(providers = [rust_common.crate_info]),
        "crate_features": attr.string_list(),
        "edition": attr.string(default = "2021"),
        "outfile": attr.string(mandatory = True),
    },
    toolchains = ["@rules_rust//rust:toolchain_type", "@bazel_tools//tools/sh:toolchain_type"],
    provides = [DefaultInfo],
)
